"""GitHub Actions Runner - Execute commands via GitHub Actions workflows."""

from __future__ import annotations

import asyncio
import json
import secrets
from dataclasses import dataclass
from datetime import datetime
from typing import Callable, Awaitable

from amadeus.db import User
from amadeus.github.client import GitHubClient
from amadeus.logging import get_logger

logger = get_logger(__name__)

# Workflow template for executing commands
WORKFLOW_TEMPLATE = """# Auto-generated by Amadeus Pocket
# This workflow will be deleted after execution

name: Amadeus Task - {task_id}

on:
  workflow_dispatch:

jobs:
  amadeus-task:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        if: {setup_node}
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup Python
        if: {setup_python}
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          {install_commands}
      
      - name: Execute Amadeus Task
        id: task
        run: |
          echo "::group::Task Output"
          {commands}
          echo "::endgroup::"
        continue-on-error: true
      
      - name: Capture output
        if: always()
        run: |
          echo "Task completed with status: ${{ steps.task.outcome }}"
"""


@dataclass
class ActionResult:
    """Result from a GitHub Action execution."""
    success: bool
    output: str
    run_id: int | None = None
    run_url: str | None = None
    duration_seconds: int = 0
    error: str | None = None


class GitHubActionsRunner:
    """Execute commands via GitHub Actions workflows."""
    
    def __init__(self):
        self.workflow_path = ".github/workflows/amadeus-task.yml"
    
    async def execute(
        self,
        user: User,
        commands: list[str],
        on_progress: Callable[[str, int], Awaitable[None]] | None = None,
    ) -> ActionResult:
        """Execute commands via GitHub Actions.
        
        Args:
            user: User with GitHub connection
            commands: List of shell commands to execute
            on_progress: Callback for progress updates (message, percentage)
        
        Returns:
            ActionResult with output and status
        """
        if not user.github.is_connected:
            return ActionResult(success=False, output="", error="GitHub not connected")
        
        if not user.github.selected_repo:
            return ActionResult(success=False, output="", error="No repository selected")
        
        owner, repo = user.github.selected_repo.split("/", 1)
        task_id = secrets.token_hex(4)
        
        async def progress(msg: str, pct: int):
            if on_progress:
                await on_progress(msg, pct)
        
        try:
            async with GitHubClient(user.github.access_token) as client:
                # Step 1: Create the workflow file
                await progress("ðŸ“ Creating workflow...", 10)
                
                workflow_content = self._generate_workflow(task_id, commands)
                
                # Check if workflow file exists
                _, existing_sha = await client.get_file_content(
                    owner, repo, self.workflow_path
                )
                
                # Create/update the workflow file
                commit = await client.create_or_update_file(
                    owner=owner,
                    repo=repo,
                    path=self.workflow_path,
                    content=workflow_content,
                    message=f"[Amadeus] Add task workflow {task_id}",
                    branch=user.github.selected_branch or "main",
                    sha=existing_sha,
                )
                
                if not commit:
                    return ActionResult(
                        success=False,
                        output="",
                        error="Failed to create workflow file"
                    )
                
                # Step 2: Trigger the workflow
                await progress("ðŸš€ Triggering workflow...", 30)
                await asyncio.sleep(2)  # Wait for GitHub to register the file
                
                triggered = await self._trigger_workflow(
                    client, owner, repo, 
                    user.github.selected_branch or "main"
                )
                
                if not triggered:
                    return ActionResult(
                        success=False,
                        output="",
                        error="Failed to trigger workflow"
                    )
                
                # Step 3: Wait for workflow to start and get run ID
                await progress("â³ Waiting for run to start...", 40)
                run_id = await self._wait_for_run(client, owner, repo, task_id)
                
                if not run_id:
                    return ActionResult(
                        success=False,
                        output="",
                        error="Could not find workflow run"
                    )
                
                run_url = f"https://github.com/{owner}/{repo}/actions/runs/{run_id}"
                
                # Step 4: Poll for completion
                await progress("âš™ï¸ Running commands...", 60)
                start_time = datetime.utcnow()
                
                status, conclusion = await self._poll_run_status(
                    client, owner, repo, run_id, 
                    on_progress=lambda msg, pct: progress(msg, 60 + int(pct * 0.3))
                )
                
                duration = int((datetime.utcnow() - start_time).total_seconds())
                
                # Step 5: Get logs
                await progress("ðŸ“‹ Fetching logs...", 95)
                logs = await self._get_run_logs(client, owner, repo, run_id)
                
                # Step 6: Cleanup workflow file
                await self._cleanup_workflow(client, owner, repo, user.github.selected_branch or "main")
                
                await progress("âœ… Complete!", 100)
                
                return ActionResult(
                    success=(conclusion == "success"),
                    output=logs,
                    run_id=run_id,
                    run_url=run_url,
                    duration_seconds=duration,
                    error=None if conclusion == "success" else f"Workflow {conclusion}"
                )
        
        except Exception as e:
            logger.exception("actions_runner.error", error=str(e))
            return ActionResult(
                success=False,
                output="",
                error=str(e)
            )
    
    def _generate_workflow(self, task_id: str, commands: list[str]) -> str:
        """Generate workflow YAML content."""
        # Detect if we need Node.js or Python
        commands_str = " ".join(commands).lower()
        setup_node = "npm" in commands_str or "yarn" in commands_str or "node" in commands_str
        setup_python = "pip" in commands_str or "python" in commands_str
        
        # Generate install commands
        install_commands = []
        if setup_node and ("package.json" in commands_str or "npm install" in commands_str):
            install_commands.append("npm ci || npm install || true")
        if setup_python and ("requirements.txt" in commands_str or "pip install" in commands_str):
            install_commands.append("pip install -r requirements.txt || true")
        
        if not install_commands:
            install_commands = ["echo 'No dependencies to install'"]
        
        # Format commands
        commands_formatted = "\n          ".join(commands)
        install_formatted = "\n          ".join(install_commands)
        
        return WORKFLOW_TEMPLATE.format(
            task_id=task_id,
            setup_node=str(setup_node).lower(),
            setup_python=str(setup_python).lower(),
            install_commands=install_formatted,
            commands=commands_formatted,
        )
    
    async def _trigger_workflow(
        self,
        client: GitHubClient,
        owner: str,
        repo: str,
        ref: str,
    ) -> bool:
        """Trigger the workflow via repository dispatch."""
        status, _ = await client._request(
            "POST",
            f"/repos/{owner}/{repo}/actions/workflows/amadeus-task.yml/dispatches",
            json={"ref": ref}
        )
        return status == 204
    
    async def _wait_for_run(
        self,
        client: GitHubClient,
        owner: str,
        repo: str,
        task_id: str,
        max_wait: int = 30,
    ) -> int | None:
        """Wait for the workflow run to appear and return its ID."""
        for _ in range(max_wait):
            status, data = await client._request(
                "GET",
                f"/repos/{owner}/{repo}/actions/runs",
                params={"per_page": 5}
            )
            
            if status == 200 and data:
                for run in data.get("workflow_runs", []):
                    if f"amadeus-task" in run.get("name", "").lower():
                        return run["id"]
            
            await asyncio.sleep(1)
        
        return None
    
    async def _poll_run_status(
        self,
        client: GitHubClient,
        owner: str,
        repo: str,
        run_id: int,
        on_progress: Callable[[str, float], Awaitable[None]] | None = None,
        timeout: int = 300,
    ) -> tuple[str, str]:
        """Poll workflow run until completion.
        
        Returns (status, conclusion).
        """
        elapsed = 0
        poll_interval = 3
        
        while elapsed < timeout:
            status, data = await client._request(
                "GET",
                f"/repos/{owner}/{repo}/actions/runs/{run_id}"
            )
            
            if status != 200 or not data:
                await asyncio.sleep(poll_interval)
                elapsed += poll_interval
                continue
            
            run_status = data.get("status")
            conclusion = data.get("conclusion")
            
            if on_progress:
                progress_pct = min(elapsed / timeout, 0.99)
                await on_progress(f"Status: {run_status}", progress_pct)
            
            if run_status == "completed":
                return run_status, conclusion or "unknown"
            
            await asyncio.sleep(poll_interval)
            elapsed += poll_interval
        
        return "timeout", "timeout"
    
    async def _get_run_logs(
        self,
        client: GitHubClient,
        owner: str,
        repo: str,
        run_id: int,
    ) -> str:
        """Get logs from the workflow run."""
        # Get jobs for this run
        status, data = await client._request(
            "GET",
            f"/repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
        )
        
        if status != 200 or not data:
            return "Could not fetch logs"
        
        jobs = data.get("jobs", [])
        if not jobs:
            return "No jobs found"
        
        # Get the main job
        job = jobs[0]
        job_id = job["id"]
        
        # Fetch job logs
        # Note: GitHub returns logs as a redirect to a download URL
        # We'll get a summary instead
        steps_output = []
        for step in job.get("steps", []):
            name = step.get("name", "Unknown")
            conclusion = step.get("conclusion", "unknown")
            icon = "âœ…" if conclusion == "success" else "âŒ" if conclusion == "failure" else "â­ï¸"
            steps_output.append(f"{icon} {name}: {conclusion}")
        
        return "\n".join(steps_output) if steps_output else "No step information available"
    
    async def _cleanup_workflow(
        self,
        client: GitHubClient,
        owner: str,
        repo: str,
        branch: str,
    ) -> None:
        """Delete the workflow file after execution."""
        try:
            _, sha = await client.get_file_content(owner, repo, self.workflow_path)
            if sha:
                await client._request(
                    "DELETE",
                    f"/repos/{owner}/{repo}/contents/{self.workflow_path}",
                    json={
                        "message": "[Amadeus] Cleanup task workflow",
                        "sha": sha,
                        "branch": branch,
                    }
                )
        except Exception:
            pass  # Ignore cleanup errors
